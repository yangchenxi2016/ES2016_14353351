<center>
##嵌入式系统实验报告
######姓名：杨晨西　　　学号：14353351　　　实验四：死锁　　　日期：2016.10.18
</center>
###一、实验过程
1. 在Ubuntu里面新建一个java文件，编写一个可能会造成死锁的程序。
2. 在终端运行 javac <文件名>编译我们写的java文件
3. 建立一个后缀为bash的脚本文件，在终端输入“chmod +x <bash文件名>”使得脚本可运行；再输入“ ./<脚本文件名> ”运行脚本
### 二、死锁停在第几次的截图  

![Deadlock](http://i.imgur.com/4nicOZY.png)  

###三、产生死锁的4个必要条件


　　死锁就是两个或者多个进程，互相请求对方占有的资源。


1. 互斥条件：一个资源每次只能被一个进程使用
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系

###四、对上述程序产生死锁的解释
　　![thread](http://i.imgur.com/zJ63sbe.png)  
　　如上图所示，线程A请求线程B的函数last(),线程B也请求线程A的函数last()，并且两个last函数都用了关键字synchronized修饰。  
　　对关键字synchronized的解释：  
　　　1. 当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。      
　　　2.  当一个线程访问object的一个synchronized同步代码块或同步方法时，其他线程对object中所有其它synchronized同步代码块或同步方法的访问将被阻塞。
